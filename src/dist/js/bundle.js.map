{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;UCLA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,UAAU;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD;AACA;AACA;AACA,uCAAuC;AACvC;AACA,CAAC;AACD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,6DAA6D;AAC7D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,gFAAgF;AAChF,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,kDAAkD;AAClD;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,uEAAuE;AACvE;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,yFAAyF;AACzF,aAAa;AACb;AACA;AACA,QAAQ;AACR;AACA,gEAAgE;AAChE;AACA;AACA,sFAAsF;AACtF,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,qEAAqE;AACrE,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E,6EAA6E;AAC7E,KAAK;AACL,CAAC;AACD;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC,4EAA4E;AAC7E;AACA;AACA,CAAC;AACD;AACA,CAAC,4EAA4E;AAC7E;AACA,CAAC,oEAAoE;AACrE;AACA,CAAC;AACD;AACA,qDAAqD;AACrD,sDAAsD;AACtD;AACA;AACA;AACA,iFAAiF;AACjF;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,KAAK;AACL,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,KAAK;AACL,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,gEAAgE;AAChE;AACA,6BAA6B,UAAU,SAAS,SAAS,cAAc,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,iDAAiD;AACjD;AACA,6BAA6B,UAAU,aAAa,cAAc,SAAS,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,gDAAgD;AAChD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,iCAAU,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a","sources":["webpack://ujs/./src/module.js","webpack://ujs/webpack/bootstrap","webpack://ujs/./src/notes.js"],"sourcesContent":["function myModule1() {\r\n    this.hello = function () {\r\n        console.log('hello')\r\n    }\r\n}\r\nmodule.exports = myModule1;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","'use strict'\r\n// === === ===  Нововведения в ES6  === === === === === === === === === === === === === === === === ===\r\n\r\n// == стрелочные функции ==\r\n// == оператор spread для массивов (начиная с ES9 - и для объектов ==\r\n// == деструктуризация ==\r\nconst obj = {\r\n    subObject: {\r\n        str: '',\r\n        num: 5\r\n    }\r\n}\r\nconst {str, num} = obj.subObject;\r\n\r\n\r\n// === === ===  Методы и свойства строк и чисел  === === === === === === === === === === === === === ===\r\n\r\nconst string = 'Пример какой-то строки';\r\nstring.toUpperCase()                            // вернуть строку с большими буквами\r\nstring.toLowerCase()                            // вернуть строку с маленькими буквами\r\nstring.indexOf('какой')                         // [7]: поиск подстроки, если подстрока не найдена - возвращает [-1]\r\nstring.slice(7, 15)                             // ['какой-то']: вырезает часть строки по индексу, последний индекс НЕ ВКЛЮЧИТЕЛЬНО.\r\n                                                // если второй аргумент не указан - вырезается часть до конца строки.\r\n                                                // если указать отрицательное значение, отсчет ведется с конца строки\r\nstring.substring(7,15)                          // ['какой-то']: почти как slice, не поддерживает отрицательные значения\r\nstring.substr(7,7)                  // ['какой-то']: вырезает часть строки по индексу и длине\r\n\r\nconst number = 12.2;\r\nMath.round(number)                              //[12]: округление числа до ближайшего целого\r\n\r\nconst test = '12.2px';\r\nparseInt(test)                                  // [12]: перевод строки в целое число\r\nparseFloat(test)                                // [12]: перевод строки в число с плавающей точкой\r\n\r\n// == превращение в строку ==\r\n\r\n// 1)\r\nlet someString = String(null)             // редко используемый способ\r\n// 2)\r\nsomeString = null + ''                         // при конкатенации чего-либо со строкой получается строка\r\n\r\n// == превращение в число ==\r\n\r\n// 1)\r\nlet someNumber = Number('45')             // редко используемый способ\r\n// 2)\r\nsomeNumber = +'46'                              // унарный плюс\r\n// 3)\r\nsomeNumber = parseInt('15px', 10)      // нечасто используется, второй аргумент - система исчисления\r\n\r\n// == превращение в boolean ==\r\n// 1)\r\n// 0, '', null, undefined, NaN;                 // нативное преобразование, перечисленное превращается в false, все остальное - в true\r\n// 2)\r\nlet someBoolean = Boolean('4')            // редко, так как есть нативное\r\n// 3)\r\nsomeBoolean = !!'444'                           // еще более редкий прием\r\n\r\n\r\n// === === ===  Методы и свойства объектов  === === === === === === === === === === === === === === ===\r\n\r\nconst object = {\r\n    string: 'some string',\r\n    number: 22,\r\n    toDelete: '',\r\n    makeTest: function () { }                   // создание метода в объекте\r\n}\r\nconst add = {\r\n    d: 17,\r\n    e: 20\r\n}\r\n\r\nfor (let key in object) { }                     // перебор опций объекта\r\ndelete object.toDelete;                         // позволяет удалить элемент из объекта\r\nObject.keys(object)                             // создает массив из ключей объекта\r\nObject.assign(object, obj)                      // объединить два объекта (объект в который нуно поместить, объект который нужно добавить\r\nObject.entries(object)                          // превращает объект в массив массивов\r\n// const json = JSON.stringify(Object.fromEntries(formData.entries()))      // formData ==> json\r\n\r\n// !!!!!!!!!!\r\n// Рассмотреть передачу по ссылке и по значению, копии объектов\r\n// !!!!!!!!!!\r\n// 1) Поверхностная копия через цикл\r\n\r\nfunction copy1(mainObj) {\r\n    let objCopy = {};\r\n    for (let key in mainObj) {\r\n        objCopy[key] = mainObj[key]\r\n    }\r\n    return objCopy;\r\n}\r\n\r\n// 2) Поверхностная копия через Object.assign\r\n\r\nObject.assign({}, add);                                     // клонируем add в пустой объект\r\n\r\n// 3) Поверхностная копия массива\r\n\r\n// array.slice()                                                  // создать поверхностную копию массива\r\n\r\n// 4) Новейший способ поверхностной копии - spread\r\n\r\n// const newArray = {...array}\r\nconst newObject = {...object}                              // можно также развоорачивать массивы в объект. аоборот - нельзя\r\n\r\n\r\n// === === ===  Методы массивов  === === === === === === === === === === === === === === === === === ===\r\n\r\nconst array = [4, 2, 3, 6, 8]\r\n\r\narray.pop();                                    // удаляет последний элемент из массива и возвращает его\r\narray.push(10);                                 // добавляет элемент в конец массива\r\nfor (let value of array) { }                    // перебор значений массива, работает break и continue\r\narray.forEach(function (                        // перебор значений массива и применение функции к каждому элементу. Не возвращает новый массив!\r\n    item,                               // значеение элемента\r\n    index,                              // индекс элемента\r\n    array) {                           // ссылка на массив\r\n\r\n})\r\narray.map(a => {})                             // перебирает и модифициррует элементы, возвращая новый массив\r\nconst split = string.split(' ')        // превращает строку в массив по разделителю\r\nsplit.join('_')                                // превращает массив в строку по разделителю\r\narray.sort()                                   // сортировка элементов массива (как строк, по первым символам)\r\n// http://algolist.ru/sort/quick_sort.php      // инфо про алгоритм быстрой сортировки\r\nfunction compareNum(a, b) {\r\n    return a - b;\r\n}\r\narray.sort(compareNum)                         // для правильной сортировки чисел\r\narray.slice()                                  // создать поверхностную копию массива\r\n//array.splice(i, c)                             // удаляет элементы из массива, (номер, количество)\r\n\r\n// Псевдомассивы - выглядят как массивы, но не имеют их методов\r\n\r\n// == Остальные методы перебора массивов ==\r\n\r\n// .filter()                                         // отфильтровываем массив по заданному критери. Возвращает новый массив\r\nconst arrayNames = ['Ivan', 'Ann', 'Ksenia', 'Voldemart']\r\nconst shortNames = arrayNames.filter((name) => {\r\n    return name.length < 5;\r\n})\r\n//console.log(shortNames)\r\n\r\n// .map()                                           // перебирает и модифициррует элементы, возвращая новый массив\r\nconst arrayAnswers = ['IvAn', 'AnnA', 'Hello'];\r\nconst resultAnswers = arrayAnswers.map(answer => answer.toLowerCase());\r\n//console.log(resultAnswers)\r\n\r\n// every/some (boolean)                             // проверяет на соответсвие условию каждый/хотя бы один элемент\r\nconst arraySome = [4, 'qwq', 'sdfsh'];\r\n//console.log(arraySome.some(item => typeof(item) === 'number'))\r\n//console.log(arraySome.every(item => typeof(item) === 'number'))\r\n    \r\n// reduce()                                           // собирает элементы массива в одно единое целое\r\nconst resultReduce = array.reduce((sum, current) => sum + current, 3) // последний аргумент - начальное значение\r\n//console.log(arrayNames.reduce((sum, current) => sum + `, ` + current, 3))\r\n\r\n\r\nconst obj3 = {\r\n    ivan: 'person',\r\n    ann: 'person',\r\n    dog: 'animal',\r\n    cat: 'animal'\r\n}\r\nconst arrayNew = Object.entries(obj3)                           // запуск методов по цепочке\r\n    .filter(item => item[1] === 'person')\r\n    .map(item => item[0])\r\n\r\n//console.log(arrayNew)\r\n\r\n\r\n// === === ===  Работа со страницей  === === === === === === === === === === === === === === === === === ===\r\n\r\nconst hi = document.getElementById('hi')\r\nconst sub = document.querySelectorAll('.sub')       // обращение ко всем элементам по селектору\r\nconst wr = document.querySelector('.wrapper')       // обращение к первому элементу по селектору\r\nconst div = document.createElement('div')           // создает элемент div\r\nconst btn1 = document.querySelector('#btn1')\r\nconst sub2 = document.querySelector('[data-current=\"2\"]')   // обращение по селектору - дата-атрибуту\r\nconst btns = document.querySelectorAll('button')\r\n\r\nwr.append(div)                                              // добавляет элемент div в конец .wrapper\r\nwr.prepend(div)                                             // добавляет элемент div в начало .wrapper\r\nsub[0].after(div)                                           // добавляет элемент div после первого sub\r\nsub[1].before(div)                                          // добавляет элемент div перед третьим sub\r\nsub[0].remove()                                             // удаляет первый элемент sub\r\nsub[2].replaceWith(sub[1])                                // заменяет второй элемент sub на hi, причем удаляет hi с прошлого места\r\n\r\ndiv.classList.add('black')                                  // добавляет элементу div класс black\r\n//div.innerHTML = '<h1>Hello</h1>'                            // добавляет html в элемент\r\n//div.textContent = 'Hello';                                  // добавляет текст в элемент\r\n\r\n//div.insertAdjacentHTML('', '<h2>Hello2</h2>')     // добавляет html перед, в начало, в конец или после элемента\r\n\r\nwr.childNodes                                               // возвращает псевдомассив дочерних узлов (нод)\r\nwr.firstChild                                               // возвращает первую ноду\r\nwr.lastChild                                                // возвращает последнюю ноду\r\nbtn1.parentNode                                             // возвращает родительскую ноду\r\nsub2.nextSibling                                            // возвращает следующую ноду\r\nsub2.previousSibling                                        // возвращает предыдущую ноду\r\n\r\n\r\nwr.firstElementChild                                        // возвращает первый элемент\r\nwr.lastElementChild                                         // возвращает последний элемент\r\nbtn1.parentElement                                          // возвращает родительский элемент\r\nsub2.nextElementSibling                                     // возвращает следующий элемент\r\nsub2.previousElementSibling                                 // возвращает предыдущий элемент\r\nfor (let node of wr.childNodes) {                           // избавляемся от текстовых нод в childNodes\r\n    if (node.nodeName == '#text') {\r\n        continue;\r\n    }\r\n}\r\n\r\n\r\n// === === ===  События и обработчики событий  === === === === === === === === === === === === === === === === === ===\r\n\r\nconst btn = document.querySelector(\"button\")\r\nconst listener = (event) => {\r\n    event.preventDefault();                                  // отменяет стандартное поведение браузера, пишется в начале\r\n    event.target;                                            // элемент, на котором сработало собитые\r\n    event.currentTarget;                                     // элемент, на котором сработал текущий слушатель (если есть всплытие событий)\r\n\r\n}\r\nbtn.addEventListener('click', listener)                 // добавляет слушатель события на элемент в порядке очереди\r\nbtn.removeEventListener('click', listener)              // удаляет слушатель события с элемента\r\n//input.addEventListener('change', listener)                 // событие change происходит, когда input теряе фокус\r\n\r\n\r\n// == == == События на мобильных устройствах == == == == == == ==\r\n\r\n// touch addEventListeners\r\n// touchstart - событие при касании к элементу\r\n// touchmove - событие при касании и однвременном смещении\r\n// touchend - событие при прикращении касания\r\n// touchenter - событие при попадании на элемент в процессе скольжения пальцем по экрану\r\n// touchleave - событие при выходе за пределы элемента в процессе скольжения пальцем по экрану\r\n// touchcancel - событие срабатывает, когда точка соприкосновения больше не регистрируется на поверности\r\n\r\n// свойства event touch\r\n// touches - выдает список всех пальцев, взаимодействующих с экраном\r\n// targetTouches - выдает список всех пальцев, взаимодействующих с элементом\r\n// changedTouches - выдает список всех пальцев, учавствующих в текущем событии\r\n//                  (будет содержать даже убранные пальцы, если все еще есть неубранные\r\n\r\n\r\n// === === ===  Загрузка скриптов на странице  === === === === === === === === === === === === === === === === === ===\r\n\r\n// <script defer src=''></script>   - скрипт с defer не блокирует загрузку DOM-структуры, подгружает скрипт паралельно DOM,\r\n//                                    срабатывает когда DOM готов. Несколько скриптов с defer загружаются последовательно\r\n// <script async src=''></script>   - скрипты с async выполняются независимо от загрузки DOM и других скриптов, как только загрузятся\r\n\r\n\r\n// === === ===  classList  === === === === === === === === === === === === === === === === === ===\r\n\r\nsub[0].classList.length                         // возвращает количество классов элемента\r\nsub[0].classList.item(0)                  // возвращает класс элемента по индексу\r\nsub[0].classList.add('new', 'new2')             // добавляет классы элементу\r\nsub[0].classList.remove('new', 'new2')   // удаляет классы у элемента\r\nsub[0].classList.toggle('new')           // если класса нет - добавляет, если есть - удаляет\r\n\r\nif (sub[0].classList.contains('new')){}         // проверка на наличие класса, возвращает true или false\r\n\r\n\r\n// === === ===  setTimeout и setInterval  === === === === === === === === === === === === === === === === === ===\r\n\r\nlet intervalCount = 0;\r\n\r\nconst setFunc = (dd) =>{\r\n    div.insertAdjacentHTML('beforeend', dd)\r\n    intervalCount++\r\n    hi.textContent = `${intervalCount}`\r\n\r\n}\r\n//const timerId =                                                   // индентификатор таймаута\r\n//    setTimeout(setFunc, 2000, ' ololo ')                          // позволяет вызвать любую операцию через промежуток времени\r\nconst intervalId =\r\n    setInterval(setFunc, 500, ' lol')             // позволяет повторять любую операцию через интервал, не ждет выполнения кода\r\nclearInterval(intervalId)                                              // сброс таймера по идентификатору\r\n\r\n\r\n// === === ===  Date  === === === === === === === === === === === === === === === === === ===\r\n\r\nconst now = new Date();                                             // получаем сегодняшнюю дату и время\r\nnow.getFullYear()                                                   // метод, получающий год\r\nnow.getMonth()                                                      // метод, получающий месяц. Номерация месяцев начинается с нуля!\r\nnow.getDate()                                                       // метод, получающий день\r\nnow.getDay()                                                        // метод, получающий день недели. Воскресенье - 0 день\r\n                                                                    // аналогично можно получить время.\r\n                                                                    // есть аналогичные команды для UTC\r\nnow.getTimezoneOffset()                                             // возвращает разницу в минутах между текущим и нулевым поясами\r\nnow.getTime()                                                       // возвращает количесвто мс, прошедших с 1.01.1970\r\nDate.parse('2021-10-29T22:30')                                   // Парсит дату из строки\r\nnow.setHours(18, 40, 4)                            // устанавливает часы (а также минуты, секунды и мс). Аналогично остальные get=>set\r\n\r\n\r\n// === === ===  Document, window  === === === === === === === === === === === === === === === === === ===\r\n\r\n\r\nhi.clientHeight                                                     // высота без margin и border\r\nhi.clientWidth                                                      // ширина без margin и border\r\nhi.offsetHeight                                                     // высота с учетом margin, border и полосы прокрутки\r\nhi.offsetWidth                                                      // ширина с учетом margin, border и полосы прокрутки\r\nhi.scrollHeight                                                     // высота с учетом margin, border и всей прокрутки, без полосы\r\nhi.scrollWidth                                                      // ширина с учетом margin, border и всей прокрутки, без полосы\r\nhi.scrollTop                                                        // высота невидимой части вверху, которую можно прокрутить. Изменяемо\r\nhi.getBoundingClientRect()                                          // получить координаты относительно левого верхнего края\r\nhi.getBoundingClientRect().top                                      // получить координаты сверху относительно левого верхнего края\r\nwindow.getComputedStyle(hi/*, after*/)                              // получить примененные стили элемента. Можно получить стили псевдоэлементов\r\nwindow.getComputedStyle(hi).display                                 // получить значение примененного стиля display у элемента\r\nhi.scrollTop = 300                                                  // модификация scrollTop\r\nhi.scrollBy(0, 400)                                           // скролл по (x, y) относительно текущей позиции\r\nhi.scrollTo(0, 400)                                           // скролл по (x, y) относительно начала страницы\r\nwindow.pageYOffset                                                  // сколько пикселей пользователь прокрутил сверху\r\n\r\n\r\ndocument.addEventListener('keydown',  (e) => {      // обработчик нажатия клавиши\r\n    if (e.code === \"Escape\") {}                                                 // https://keycode.info/\r\n});\r\n\r\nbtns[2].addEventListener('click', () => {\r\n    //hi.style.height = hi.scrollHeight + 'px';\r\n    hi.scrollBy(0, 400)\r\n})\r\n\r\n\r\n// === === ===  Функции-конструкторы. Контекст вызова. This  === === === === === === === === === === === === === === === === === ===\r\n\r\nfunction User(name, id) {                                   // функция-конструктор\r\n    this.name = name;\r\n    this.id = id;\r\n    this.function = function () {};\r\n}\r\nUser.prototype.method = function () {}                      // добавляем методы или свойства в уже существующую функцию. Метод будет у всех последующих объектов\r\nconst ivan = new User('Ivan', 28);                // объект,созданный функцией-конструктором\r\n// Классы - синтаксический сахар для функций-конструкторов\r\n// Функция может вызываться четырьмя способами. и в каждой контекст вызова отличается\r\n\r\n// 1) Обычная функция\r\nfunction showThis() {                                       // Если не используется 'use strict' - возвращает объект Window\r\n    console.log(this)                                       // Если используется 'use strict' - возвращает undefined\r\n}\r\n//showThis();\r\n\r\n// 2) Функция - метод объекта\r\nconst objThis = {\r\n    a: 20,\r\n    b: 15,\r\n    sum: function () {                                       // Контекс у методов объекта - сам объект\r\n        console.log(this)\r\n    }\r\n}\r\n//objThis.sum();\r\n\r\n// 3) Конструкторы\r\nfunction This(name, id) {                                   // Контекст в конструкторах и классах - новый экземпляр объекта\r\n    this.name = name;\r\n    this.id = id;\r\n    this.function = function () {};\r\n}\r\n\r\n// 4) Ручная привязка this: call, apply, bind\r\nfunction sayName(surname) {\r\n    console.log(this)\r\n    console.log(this.name + surname)\r\n}\r\nconst user = {\r\n    name: 'John'\r\n}\r\n//sayName.call(user, 'Smith');                                         // передаем контекст вызова в функцию.\r\n//sayName.apply(user, ['Smith']);                                      // то же самое. Разницы в функциональности нет, только в синтаксисе\r\n\r\nfunction count(num) {                                                // создает новую функцию, и подвязывает контекст\r\n    return this*num;\r\n}\r\n//const double = count.bind(2);\r\n//console.log(double(3))\r\n\r\n// == == == Примеры == == ==\r\n\r\nbtns[3].addEventListener('click', function (){          // если классическая функция - контекстом будет сам объект \r\n    console.log(this)\r\n    this.style.backgroundColor = 'red'\r\n})\r\nconst obj2 = {\r\n    num: 5,\r\n    sayNumber: function () {\r\n        const say = () => {                                           // стрелочная функция не имеет своего контекста и берет его у родителя\r\n            console.log(this.num)\r\n        };\r\n        say();\r\n    }\r\n}\r\n//obj2.sayNumber()\r\n\r\n\r\n// === === ===  Классы  === === === === === === === === === === === === === === === === === ===\r\n\r\n\r\n\r\n// === === ===  Rest оператор и параметры по умолчанию  === === === === === === === === === === === === === === ===\r\n\r\n// Spread берет сущность  раскладывает ее на отдельные элементы\r\n// Rest отдельные элементы объединяет в один массив\r\n\r\nconst log = function (a, b, ...rest) {\r\n    console.log(a, b, rest)\r\n}\r\n//log('basic','rest', 'operator', 'usage')\r\n\r\nfunction calcOrDouble(number, basis = 3) {\r\n    //basis = basis || 3\r\n\r\n    console.log(number * basis)\r\n}\r\n//calcOrDouble(2, 3)\r\n\r\n\r\n// === === ===  JSON  === === === === === === === === === === === === === === === === === === === === ===\r\n\r\n\r\nconst person = {\r\n    name: \"Alex\",\r\n    tel: \"+380677777777\",\r\n    parents: {\r\n        mom: 'Olga',\r\n        dad: 'Mike'\r\n    }\r\n}\r\nconst strng = JSON.stringify(person)                                    // Переводит в подходящий для передачи формат json\r\nconst clone = JSON.parse(strng)                                         // Переводит из json назад\r\n                                                                        // две операции выше осуществили глубокое копирование\r\n\r\n// === === ===  AJAX (asynchronous Javascript and XML) и общение с сервером. Promises === === === === === === === === ===\r\n\r\n// 1) XML HTTP Request - уже не совсем актуален\r\n\r\nconst inputUah = document.querySelector('#uah'),\r\n    inputUsd = document.querySelector('#usd')\r\n\r\ninputUah.addEventListener('input', (e) => {\r\n    const request = new XMLHttpRequest();\r\n\r\n    //// далее - методы XMLHttpRequest\r\n    request.open(                                               // метод open(method, url, async, login, password) собирает настройки запроса\r\n        'GET',\r\n        'notes.json'                                        // путь нужно указывать относительно html файла\r\n    );\r\n    request.setRequestHeader(                                   // указать серверу, что в запросе\r\n        'Content-type',                                   // имя - тип контента\r\n        'application/json; charset=utf-8'                 // тип контента и кодировка\r\n    )\r\n    request.send()                                              // отправляем запрост (для некоторых методов, например пост, принимает аргумент body)\r\n\r\n    //// далее - свойства XMLHttpRequest\r\n    request.status                                              // статус запроса (например 404)\r\n    request.statusText                                          // текстовое описание статус запроса (например NOT FOUND)\r\n    request.response                                            // ответ от сервера\r\n    request.readyState                                          // текущее состояние объекта. https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/readyState\r\n\r\n    //// далее - события XMLHttpRequest\r\n    // интуитивно понятные: loadstart, progress, abort, timeout, loadend\r\n    \r\n    // request.addEventListener('readystatechange', () => {        // событие, следящее за readyState\r\n    //     if (request.readyState === 4 && request.status === 200) {\r\n    //         const data = JSON.parse(request.response);\r\n    //         inputUsd.value = '$' + (+e.target.value / data.current.usd).toFixed(2);   // округлили до двух знаков\r\n    //     } else {\r\n    //         inputUsd.value = 'Error'\r\n    //     }\r\n    // })\r\n\r\n    request.addEventListener('load', () => {                    // событие, когда запрос завершен\r\n        if (request.status === 200) {\r\n            const data = JSON.parse(request.response);\r\n            inputUsd.value = '$' + (+e.target.value / data.current.usd).toFixed(2);   // округлили до двух знаков\r\n        } else {\r\n            inputUsd.value = 'Error'\r\n        }\r\n    })\r\n\r\n    // request.setRequestHeader('Content-type', 'multipart/form-data');      // при использовании FormData и XMLHttpRequest хедер не писать!\r\n    const formData = new FormData('form');                                   // позволяет собрать все данные с аттрибутом name из формы\r\n    const json = JSON.stringify(Object.fromEntries(formData.entries()))      // formData ==> json\r\n\r\n})\r\n\r\n// 2) Promises\r\n\r\n//console.log('Zapros')\r\nconst req = new Promise(function (resolve, reject){                  // создаем промис\r\n    setTimeout(() => {                                                // асинхронная функция\r\n        //console.log('Podgotovka')\r\n        const product = {\r\n            name: 'TV',\r\n            price: '2000'\r\n        }\r\n        resolve(product);                                                    // в случае успеха\r\n        reject();                                                            // в случае неудачи\r\n    }, 2000)\r\n})\r\n\r\nreq.then((product) => {                                                      // начинаем вызов цепочки промисов\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            product.status = 'order';\r\n            resolve(product)\r\n        }, 2000)\r\n    })\r\n}).then(data => {                                                            // второй промис\r\n    data.modify = true;\r\n    return data;\r\n}).then((data) => {\r\n    //console.log(data);\r\n}).catch(() => {                                                             // обработка ошибки\r\n    //console.error('ERROR')\r\n}).finally(() => {                                                   // после всего,в любом случае\r\n    //console.log('Finally')\r\n})\r\n\r\n//Promise.all([promise1(), promise2()]).then(() => {})                    // ждет выполнения всех промисов, и выполняется дальше\r\n//Promise.race([promise1(), promise2()]).then(() => {})                    // ждет выполнения первого промиса, и выполняется дальше\r\n\r\n// 3) Fetch API (application programming interface)\r\n\r\nconst fetchRes = fetch('https://jsonplaceholder.typicode.com/posts',{            // объект с настройками запроса\r\n    method: \"POST\",\r\n    body: JSON.stringify({name: 'alex'}),\r\n    headers:{\r\n        'Content-type': 'application/json'\r\n    }\r\n}).then(response => {\r\n        //console.log(response.ok)                                        // boolean свойство fetch\r\n        //console.log(response.status)                                    // свойство fetch, возвращающее статус, например 200, 404...\r\n        return response.json()                                          // метод fetch, аналог JSON.parse. Возвращает промис\r\n    })\r\n    .then(json => {})\r\n\r\n// 3) axios\r\n\r\n// # npm install axios\r\n// <script src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"></script>\r\n// Документация: https://github.com/axios/axios\r\n\r\n\r\n// === === ===  localStorage === === === === === === === === ===\r\n\r\nlocalStorage.setItem('keyName', 5)\r\nlocalStorage.getItem('keyName')\r\nlocalStorage.removeItem('keyName')\r\nlocalStorage.clear()\r\n\r\n\r\n// === === ===  Регулярные выражения === === === === === === === === ===\r\n\r\n// Любое регулярное выражение состоит из двух частей - паттерна и флагов\r\n// new RegExp('pattern', 'flags')                  // классический синтаксис, которым никто не ползуется\r\n// /patten/flags                                   // используемый способ\r\n// Флаги:   i - поиск вне зависимости от регистра\r\n//          g - поиск нескольких вхождений\r\n//          m - многострочный режим\r\n// Спецсимволы:     \\. - обратный слеш экранирует символы\r\n//                  . - любой символ\r\n// Классы           \\d - цифры,   \\D - не цифры\r\n//                  \\w - символы,   \\W - не символы\r\n//                  \\s - пробелы, \\S - не пробелы\r\n\r\nconst ans = '200px';\r\nconst str1 = 'My name is R2D2'\r\nconst reg = /\\D\\S/ig;\r\n\r\nans.search(reg);                                    // строковый метод search, не использует флаг g\r\nans.match(reg)                                      // строковый метод match, использует флаг g\r\n'12-34-56'.replace(/-/g, ':')  // строковый метод replace, заменяет вхождения\r\nreg.test(ans)                                       // boolean метод регулярки, проверяет, есть ли соответствия\r\n\r\n\r\n// === === ===  Свойства-акцессоры === === === === === === === === ===\r\n\r\n// Свойства-акцессоры - целый комплекс, позволяют присваивать и получать значения, но во внешнем коде выглядят как обычные свойства.\r\n// Делятся на геттеры и сеттеры\r\n\r\nconst persone = {\r\n    name: 'Alex',\r\n    age: 25,\r\n    get userAge() {                                 // задаем геттер, при обращении к которому как к свойству будет возвращен return\r\n        return this.age;\r\n    },\r\n    set userAge(num) {                              // задаем сеттер с тем же именем? ему можно передать аргумент при вызове\r\n        this.age = num;\r\n    }\r\n}\r\npersone.userAge;\r\npersone.userAge = 30;\r\n\r\n\r\n// === === ===  Инкапсуляция === === === === === === === === ===\r\n\r\nfunction User1(name, age) {\r\n    this.name =name;\r\n    this.age = age;                                             // к этому свойству есть доступ снаружи\r\n    let userAge = age;                                          // к этой переменной нет доступа снаружи\r\n    this.say = function () {\r\n        console.log(`Name: ${this.name}, age: ${this.age}, user age: ${userAge}`)\r\n    }\r\n    this.getAge = function () {\r\n        return userAge;\r\n    }\r\n    this.setAge = function (age) {\r\n        if (typeof age === 'number' && age > 0 && age < 110) {\r\n            userAge = age;\r\n        } else {\r\n            console.log('Error')\r\n        }\r\n    }\r\n}\r\nconst alex = new User1('Alex', 27);\r\nalex.age = 30;\r\nalex.setAge(31)\r\n// alex.say();\r\n\r\nclass User2 {\r\n    constructor(name, age) {\r\n        this.name =name;\r\n        this._age = age;                        // к свойству, начиннающемуся с _, нельзя обращаться извне. не синтаксис, соглашение\r\n    }\r\n    #surname = 'Petrychenko';                    // запись свойства вне конструктора. # делает его приватным\r\n    say = () => {\r\n        console.log(`Name: ${this.name}, surname: ${this.#surname}, age: ${this._age}`)\r\n    }\r\n\r\n    get surname() {\r\n        return this.#surname;\r\n    }\r\n    set surname(surname) {\r\n        this.#surname = surname;\r\n    }\r\n    get age() {                                 // геттер\r\n        return this._age;\r\n    }\r\n    set age(age) {                              // сеттер\r\n        if (typeof age === 'number' && age > 0 && age < 110) {\r\n            this._age = age;\r\n        } else {\r\n            console.log('Error')\r\n        }\r\n    }\r\n}\r\nconst bob = new User2('Bob', 27);\r\n\r\n\r\n\r\n// === === ===  Модули === === === === === === === === ===\r\n\r\n// Используется, чтобы скрыть внутренние детали реализации скрипта. За нас это будет делать вебпак\r\n\r\n// 2 способа создания модулей через нативную реализацию:\r\n// 1) Использовать анонимную самовызывающуюся функцию\r\n\r\nconst number2 = 1;\r\n\r\n(function () {\r\n    let number2 = 2;\r\n    //console.log(number2)\r\n    //console.log(number2 + 3)\r\n}());\r\n//console.log(number2)\r\n\r\n// 2) Использование объектного интерфейса\r\n\r\nconst user1 = (function () {\r\n    const privat = function () {\r\n        console.log('I am privat')\r\n    }\r\n    return {\r\n        sayHello: privat                                // экспортируем метод\r\n    }\r\n}())\r\n//user1.sayHello()                                        // используем метод\r\n\r\n\r\n// === === ===  Webpack - сборщик модулей === === === === === === === === ===\r\n\r\n// # npm install webpack webpack-cli --save-dev\r\n\r\n// == == Модули CommonJS == ==\r\n\r\n// function myModule1() {                       // экспортируем из module.js\r\n//     this.hello = function () {\r\n//         console.log('hello')\r\n//     }\r\n// }\r\n// module.exports = myModule1;\r\n\r\nconst myModule1 = require('./module');          // импортируем\r\nconst myModuleInstance = new myModule1();\r\nmyModuleInstance.hello();\r\n\r\n// Любую модульную систему нужно собрать в один проект, например с помощью webpack\r\n// Gulp - планировщик задач.\r\n// Webpack - сборщик модулей, настраивается для сборки проекта\r\n// С конфигурацией по умолчанию webpack работает с файлом /src/index.js\r\n\r\n// Разберем конфигурационный файл webpack.config.js\r\n\r\n// let path = require('path');\r\n//\r\n// module.exports = {\r\n//     mode: 'development',                         // Режим работы: development/production/none\r\n//     entry: './js/script.js',                     // файл, с которого будем начинать, в котором прописываются все require и import\r\n                                                    // для нескольких файлов мжно создать объект\r\n//     output: {\r\n//         filename: 'bundle.js',\r\n//         path: __dirname + '/js'\r\n//     },\r\n//     watch: true,                                 // пересобирает проект после сохранения изменений\r\n//\r\n//     devtool: \"source-map\",                       // хранит информацию об исходниках. есть разные режимы\r\n//\r\n//     module: {}\r\n// };\r\n\r\n\r\n\r\n\r\n\r\n// === === ===  npm project  === === === === === === === === ===\r\n\r\n// # npm init                                               // инициализация. далее ответить на вопросы\r\n// i -g - установить глобально\r\n// i --save-dev - зависимость для разработки\r\n// i --save - используются внутри проекта\r\n\r\n\r\n// === === ===  json server  === === === === === === === === ===\r\n\r\n// # npm i json-server --save-dev\r\n\r\n// # json-server project_3/db.json\r\n\r\n\r\n// Shift+F5 - сброс кеша\r\n\r\nconsole.log()"],"names":[],"sourceRoot":""}